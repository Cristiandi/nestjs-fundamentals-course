- install nestjs
  ~ npm i -g @nestjs/cli

- check the version of nestjs
  ~ nestjs --version

- nestjs cli
it's a compendium tool for nestjs that helps us to generate files, run, compile and even bundle our applications.

- create a nestjs app
  ~ nestjs new

- main.ts
the entire nestjs application starts with the main.ts file, its like the main starting file for the tipycal
nodejs application.

- AppModule
AppModule module its the root module for the application containing everything itself that an app needs to
run this root module can contain others modules there all different features and tunks themselfs, but when
we brought together we get a complete application.

- Decoratos
are simple functions that apply logic.

- Modular project architecture
allow to group features such as routes, services, models into their own modules, and at the end this help us 
maintaining a high level of reusability and testability.

- generate nestjs controller
  ~nest generate controller
  ~nest g co
  ~nest g co --no-spec
  ~nest generate controller modules/abc --dry-run

- @Res() response: Response 
  its a decorator that allow to full control the response object of express... doing this is not fully
  recommended because it decrese the compatibility with the framework.

- @HttpCode(HttpStatus.GONE)
  its a decorator that set the HttpCode code response for controller method... doing this is not fully
  recommended because it decrese the compatibility with the framework.

- Services
Services are very important parts of nestjs applications as they help us separate our business logic from
our controllers, separating out business logic helps make this logic reusable throughout multiple parts
of our application.

- generate nestjs service
  ~nest generate service
  ~nest g s
  ~nest g s --no-spec

- provider
the main idea of a provider is that it can inject dependencies, this means that objects can create various
relationships to each others, and the logic of wiring up instances of objects together can all be handled
by the nest runtime system.

- modules
are strongly recommended as an efective way to organize the application components for most of nest apps
and ideal architecture should employ multiple modules, each encapsulating a closely related set of capabilities

- generate nestjs module
  ~nest generate module <module's name>
  ~nest g module <module's name>

- Nest Modules contain 4 main things:
  controllers - Which you can think of as our API Routes, that we want this module to instantiate.
  
  exports - Here we can list providers within this current module that should be made available 
  anywhere this module is imported

  imports - Just as we saw in the AppModule, the imports Array gives us the ability to list OTHER modules that
  THIS module requires. Any exported providers of these imported modules are now fully available here as well.

  providers - Here we’re going to list our services that need to be instantiated by the Nest injector.
  Any providers here will be available only within “THIS” module itself, unless added to the exports array we
  saw above.

- DTO (Data Transfer object)
is an object that is used to encasulate data and send it from on app to another, DTO's help us define the
interfaces or input and output within our system.

- generate nestjs DTO
  ~nest g class coffees/dto/create-coffee.dto --no-spec

- ValidationPipe
its a tool that comes in nestjs to automatically validate the request, this tool provides a convenient way of
enforcing validation rules all incoming client payloads.
with the option whitelist: true it cleans the request payloads from non existing attributes in DTOs
with forbidNonWhitelisted: true it throw an error when the request payloads has non existing attributes in DTOs
with the option transform: true it'll transform the payload request in DTO instance automatically
with transformOptions.enableImplicitConversion: true set the ValidationPipe no longer have to explicity specify types
with the @Type() decorator

- Entity in TypeORM
it represent a relationship between a TypeScrpt class and database table

- .forFeature()
the use of forFeature() registers TypeORM in a child module
- .forRoot()
the use of forRoot() registers TypeORM in a AppModule but we do that once.

- Repository pattern in TypeORM
this means that each Entity we create has its own repository, the repository class available from TypeORM acts
an abstraction over out data source and exposes a variety of useful methods to interact with the records stored
in our database

- Generate a migration in TypeORM
  ~npx typeorm migration:create -n <migration_name>
- Run migrations in TypeORM
  ~npx typeorm migration:run
- Rollback migrations in TypeORM
  ~npx typeorm migration:revert
- Generate migrations based on comparation vs DB and Entities
  ~npx typeorm migration:generate -n <migration_name>